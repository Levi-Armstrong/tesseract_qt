/****************************************************************************
**
** Copyright (C) 2016 - 2017
**
** This file is generated by the Magus toolkit
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
** "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE go (ODS OR SERVICES; LOSS OF USE,
** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
**
****************************************************************************/

#include <tesseract_common/types.h>
#include <tesseract_qt/rendering/ogre2/ogre2_renderman.h>
#include <OgreConfigFile.h>
#include <OgreArchiveManager.h>
#include <OgreHlms.h>
#include <OgreHlmsUnlit.h>
#include <OgreHlmsPbs.h>
#include <OgreHlmsManager.h>
#include <OgreHlmsCommon.h>
#include <OgreLogManager.h>
#include <OgreFrameStats.h>

namespace tesseract_gui
{
//****************************************************************************/
OgreManager::OgreManager(void)
{
  mGlContext = 0;
  mCompositorPassProvider = 0;
  mPause = true;

#if _DEBUG || DEBUG
  mResourcesCfg = "resources_d.cfg";
  mPluginsCfg = "plugins_d.cfg";
#else
  mResourcesCfg = "resources.cfg";
  mPluginsCfg = "plugins.cfg";
#endif

  // Create Ogre tt and initialize
  mRoot = new Ogre::Root(mPluginsCfg);

  // TEST: Levi force render system
  mRoot->loadPlugin("/usr/lib/x86_64-linux-gnu/OGRE-2.2/OGRE/RenderSystem_GL3Plus");
  Ogre::RenderSystem* renderSystem = mRoot->getRenderSystemByName(OGRE_RENDERSYSTEM_OPENGL3PLUS);
  Ogre::RenderSystemList rsList;

  // Setup renderer
  mCurrentRenderSystem = 0;
  //        const Ogre::RenderSystemList& rsList = mRoot->getAvailableRenderers();
  //        Ogre::RenderSystem* renderSystem = rsList[0];
  std::vector<Ogre::String> renderOrder;
#if defined(Q_OS_WIN)
  renderOrder.push_back("Direct3D11");
#endif
  renderOrder.push_back("OpenGL 3+");
  for (std::vector<Ogre::String>::iterator iter = renderOrder.begin(); iter != renderOrder.end(); iter++)
  {
    for (Ogre::RenderSystemList::const_iterator it = rsList.begin(); it != rsList.end(); it++)
    {
      if ((*it)->getName().find(*iter) != Ogre::String::npos)
      {
        renderSystem = *it;
        break;
      }
    }
    if (renderSystem != 0)
      break;
  }

  if (renderSystem == 0)
  {
    if (!mRoot->restoreConfig())
    {
      if (!mRoot->showConfigDialog())
        OGRE_EXCEPT(
            Ogre::Exception::ERR_INVALIDPARAMS, "Abort render system configuration", "OgreManager::OgreManager");
    }
  }

  renderSystem->setConfigOption("Full Screen", "No");
  renderSystem->setConfigOption("VSync", "Yes");
  mRoot->setRenderSystem(renderSystem);
  mCurrentRenderSystem = renderSystem;

  // Uncomment next line to show dialog
  // if(mRoot->restoreConfig() || mRoot->showConfigDialog())
  //{
  mRoot->initialise(false);
  //}

  // Initialize resources
  setupResources();

  // Start timer
  mTimer = new Ogre::Timer();
  mTimer->reset();
}

//****************************************************************************/
OgreManager::~OgreManager(void)
{
  // Added removeAllWorkspaces after Ogre 2.1 upgrade (commit 2783a361c0b8)
  // In debug mode, the application crashed in deleting mRoot
  Ogre::CompositorManager2* compositorManager = mRoot->getCompositorManager2();
  compositorManager->removeAllWorkspaces();

  // Delete the dummy CompositorPassProvider
  compositorManager->setCompositorPassProvider(0);
  OGRE_DELETE mCompositorPassProvider;

  // Destroy render textures
  // This is a piece of custom code specific for the HLMS Editor (assume that the OgreWidget is still available)
  QMap<int, QOgreWidget*>::iterator i;
  QOgreWidget* item = 0;
  for (i = mQOgreWidgetMap.begin(); i != mQOgreWidgetMap.end(); ++i)
  {
    item = i.value();
    item->cleanup();
  }

  // Delete Ogre root
  delete mRoot;
}

//-------------------------------------------------------------------------------------
void OgreManager::initialize(void)
{
  // Create dummy CompositorPassProvider (see
  // http://www.ogre3d.org/forums/viewtopic.php?f=11&t=84816&p=525752&hilit=CompositorPassProvider#p525752) If one of
  // the resource locations contains a compositor with a custom pass, the editor doesn't work anymore. This is to
  // prevent it
  //        Ogre::MyCompositorPassProvider* mCompositorPassProvider = OGRE_NEW Ogre::MyCompositorPassProvider; // Levi
  //        Commented Ogre::CompositorManager2* compositorManager = mRoot->getCompositorManager2();
  //        compositorManager->setCompositorPassProvider(mCompositorPassProvider);

  // After resources have been setup and renderwindows created (in ogre widget), the Hlms managers are registered
  registerHlms();

  // Initialise, parse scripts etc
  try
  {
    Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups(false);
  }
  catch (Ogre::Exception e)
  {
  }
  mPause = false;
  try
  {
    mRoot->renderOneFrame();  // Render first
  }
  catch (Ogre::Exception e)
  {
  }
}

//-------------------------------------------------------------------------------------
void OgreManager::setupResources(void)
{
  //        // Load resource paths from config file
  //        Ogre::ConfigFile cf;
  //        cf.load(mResourcesCfg);

  //        // Go through all sections & settings in the file
  //        Ogre::ConfigFile::SectionIterator seci = cf.getSectionIterator();

  //        Ogre::String secName, typeName, archName;
  //        while( seci.hasMoreElements() )
  //        {
  //            secName = seci.peekNextKey();
  //            Ogre::ConfigFile::SettingsMultiMap *settings = seci.getNext();

  //            if( secName != "Hlms" )
  //            {
  //                Ogre::ConfigFile::SettingsMultiMap::iterator i;
  //                for (i = settings->begin(); i != settings->end(); ++i)
  //                {
  //                    typeName = i->first;
  //                    archName = i->second;
  //                    Ogre::ResourceGroupManager::getSingleton().addResourceLocation( archName, typeName, secName );
  //                }
  //            }
  //        }
}

//****************************************************************************/
bool OgreManager::isRenderSystemGL(void)
{
  if (mCurrentRenderSystem)
    return (mCurrentRenderSystem->getName() == OGRE_RENDERSYSTEM_OPENGL3PLUS);

  return false;
}

//****************************************************************************/
GL_CONTEXT OgreManager::getGlContext(void) const { return mGlContext; }

//****************************************************************************/
void OgreManager::setGlContext(GL_CONTEXT glContext) { mGlContext = glContext; }

//****************************************************************************/
void OgreManager::registerHlms()
{
  const char* env = std::getenv("TESSERACT_QT_OGRE2_RESOURCE_PATH");

  tesseract_common::fs::path resourcePath = (env) ? std::string(env) : TESSERACT_QT_OGRE2_RESOURCE_PATH;
  tesseract_common::fs::path mediaPath(resourcePath);
  mediaPath.append("media");

  // register PbsMaterial resources
  tesseract_common::fs::path rootHlmsFolder{ mediaPath };
  tesseract_common::fs::path pbsCompositorFolder{ rootHlmsFolder };
  pbsCompositorFolder.append("2.0").append("scripts").append("Compositors");
  Ogre::ResourceGroupManager::getSingleton().addResourceLocation(pbsCompositorFolder.c_str(), "FileSystem", "General");

  tesseract_common::fs::path commonMaterialFolder{ rootHlmsFolder };
  commonMaterialFolder.append("2.0").append("scripts").append("materials").append("Common");
  Ogre::ResourceGroupManager::getSingleton().addResourceLocation(commonMaterialFolder.c_str(), "FileSystem", "General");

  tesseract_common::fs::path commonGLSLMaterialFolder{ rootHlmsFolder };
  commonGLSLMaterialFolder.append("2.0").append("scripts").append("materials").append("Common").append("GLSL");
  Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
      commonGLSLMaterialFolder.c_str(), "FileSystem", "General");

  tesseract_common::fs::path terraMaterialFolder{ rootHlmsFolder };
  terraMaterialFolder.append("2.0").append("scripts").append("materials").append("Terra");
  Ogre::ResourceGroupManager::getSingleton().addResourceLocation(terraMaterialFolder.c_str(), "FileSystem", "General");

  tesseract_common::fs::path terraGLSLMaterialFolder{ rootHlmsFolder };
  terraGLSLMaterialFolder.append("2.0").append("scripts").append("materials").append("Terra").append("GLSL");
  Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
      terraGLSLMaterialFolder.c_str(), "FileSystem", "General");

  if (mRoot->getRenderSystem()->getName() == OGRE_RENDERSYSTEM_METAL)
  {
    tesseract_common::fs::path commonMetalMaterialFolder{ rootHlmsFolder };
    commonMetalMaterialFolder.append("2.0").append("scripts").append("materials").append("Common").append("Metal");
    Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
        commonMetalMaterialFolder.c_str(), "FileSystem", "General");

    tesseract_common::fs::path terraMetalMaterialFolder{ rootHlmsFolder };
    terraMetalMaterialFolder.append("2.0").append("scripts").append("materials").append("Terra").append("Metal");
    Ogre::ResourceGroupManager::getSingleton().addResourceLocation(
        terraMetalMaterialFolder.c_str(), "FileSystem", "General");
  }

  // The following code is taken from the registerHlms() function in ogre2 samples framework
  if (rootHlmsFolder.empty())
    rootHlmsFolder = "./";

  // At this point rootHlmsFolder should be a valid path to the Hlms data folder

  // For retrieval of the paths to the different folders needed
  Ogre::String mainFolderPath;
  Ogre::StringVector libraryFoldersPaths;
  Ogre::ArchiveManager& archiveManager = Ogre::ArchiveManager::getSingleton();

  tesseract_common::fs::path customizationsArchiveLibraryFolder{ rootHlmsFolder };
  customizationsArchiveLibraryFolder.append("Hlms").append("Gz");
  Ogre::Archive* customizationsArchiveLibrary =
      archiveManager.load(customizationsArchiveLibraryFolder.c_str(), "FileSystem", true);

  {
    Ogre::HlmsUnlit::getDefaultPaths(mainFolderPath, libraryFoldersPaths);

    tesseract_common::fs::path unlitMainFolderPath{ rootHlmsFolder };
    unlitMainFolderPath.append(mainFolderPath);

    std::vector<tesseract_common::fs::path> unlitLibraryFoldersPaths;
    for (const auto& p : libraryFoldersPaths)
      unlitLibraryFoldersPaths.push_back(tesseract_common::fs::path(rootHlmsFolder).append(p));

    unlitLibraryFoldersPaths.push_back(
        tesseract_common::fs::path(rootHlmsFolder).append("Hlms").append("Gz").append("SolidColor"));
    unlitLibraryFoldersPaths.push_back(
        tesseract_common::fs::path(rootHlmsFolder).append("Hlms").append("Gz").append("SphericalClipMinDistance"));
    unlitLibraryFoldersPaths.push_back(
        tesseract_common::fs::path(rootHlmsFolder).append("Hlms").append("Gz").append("Pbs"));

    Ogre::HlmsUnlit* hlmsUnlit = 0;
    Ogre::Archive* archiveUnlit = archiveManager.load(unlitMainFolderPath.c_str(), "FileSystem", true);
    Ogre::ArchiveVec archiveUnlitLibraryFolders;

    for (const auto& p : unlitLibraryFoldersPaths)
    {
      Ogre::Archive* archiveLibrary = archiveManager.load(p.c_str(), "FileSystem", true);
      archiveUnlitLibraryFolders.push_back(archiveLibrary);
    }

    archiveUnlitLibraryFolders.push_back(customizationsArchiveLibrary);

    // Create and register the unlit Hlms
    hlmsUnlit = OGRE_NEW Ogre::HlmsUnlit(archiveUnlit, &archiveUnlitLibraryFolders);
    mRoot->getHlmsManager()->registerHlms(hlmsUnlit);
    //        Ogre::Root::getSingleton().getHlmsManager()->registerHlms( hlmsUnlit );

    // disable writting debug output to disk
    //    hlmsUnlit->setDebugOutputPath(false, false);
    //    hlmsUnlit->setListener(hlmsUnlit);

    //    this->dataPtr->gzHlmsUnlit = hlmsUnlit;
  }

  {
    Ogre::HlmsPbs::getDefaultPaths(mainFolderPath, libraryFoldersPaths);

    tesseract_common::fs::path pbsMainFolderPath{ rootHlmsFolder };
    pbsMainFolderPath.append(mainFolderPath);

    std::vector<tesseract_common::fs::path> pbsLibraryFoldersPaths;
    for (const auto& p : libraryFoldersPaths)
      pbsLibraryFoldersPaths.push_back(tesseract_common::fs::path(rootHlmsFolder).append(p));

    pbsLibraryFoldersPaths.push_back(
        tesseract_common::fs::path(rootHlmsFolder).append("Hlms").append("Gz").append("SolidColor"));
    pbsLibraryFoldersPaths.push_back(
        tesseract_common::fs::path(rootHlmsFolder).append("Hlms").append("Gz").append("SphericalClipMinDistance"));
    pbsLibraryFoldersPaths.push_back(
        tesseract_common::fs::path(rootHlmsFolder).append("Hlms").append("Gz").append("Pbs"));

    Ogre::HlmsPbs* hlmsPbs = 0;
    Ogre::Archive* archivePbs = archiveManager.load(pbsMainFolderPath.c_str(), "FileSystem", true);

    // Get the library archive(s)
    Ogre::ArchiveVec archivePbsLibraryFolders;

    {
      tesseract_common::fs::path pbs_path{ rootHlmsFolder };
      pbs_path.append("Hlms").append("Terra").append("GLSL").append("PbsTerraShadows");

      archivePbsLibraryFolders.push_back(archiveManager.load(pbs_path.c_str(), "FileSystem", true));
      //      this->dataPtr->hlmsPbsTerraShadows.reset(new Ogre::HlmsPbsTerraShadows());
    }

    for (const auto& p : pbsLibraryFoldersPaths)
    {
      Ogre::Archive* archiveLibrary = archiveManager.load(p.c_str(), "FileSystem", true);
      archivePbsLibraryFolders.push_back(archiveLibrary);
    }

    archivePbsLibraryFolders.push_back(customizationsArchiveLibrary);

    // Create and register
    hlmsPbs = OGRE_NEW Ogre::HlmsPbs(archivePbs, &archivePbsLibraryFolders);
    Ogre::Root::getSingleton().getHlmsManager()->registerHlms(hlmsPbs);

    // disable writting debug output to disk
    //    hlmsPbs->setDebugOutputPath(false, false);
    //    hlmsPbs->setListener(hlmsPbs);

    //    dataPtr->gzHlmsPbs = hlmsPbs;
  }

  //  {
  //    Ogre::Ogre2GzHlmsTerra *hlmsTerra = 0;
  //    // Create & Register HlmsPbs
  //    // Do the same for HlmsPbs:
  //    Ogre::Ogre2GzHlmsTerra::GetDefaultPaths(mainFolderPath,
  //                                             libraryFoldersPaths);
  //    Ogre::Archive *archiveTerra = archiveManager.load(
  //        rootHlmsFolder + mainFolderPath, "FileSystem", true);

  //    // Get the library archive(s)
  //    Ogre::ArchiveVec archiveTerraLibraryFolders;
  //    libraryFolderPathIt = libraryFoldersPaths.begin();
  //    libraryFolderPathEn = libraryFoldersPaths.end();
  //    while (libraryFolderPathIt != libraryFolderPathEn)
  //    {
  //      Ogre::Archive *archiveLibrary =
  //          archiveManager.load(rootHlmsFolder + *libraryFolderPathIt,
  //          "FileSystem", true);
  //      archiveTerraLibraryFolders.push_back(archiveLibrary);
  //      ++libraryFolderPathIt;
  //    }

  //    // Create and register
  //    hlmsTerra = OGRE_NEW Ogre::Ogre2GzHlmsTerra(
  //      archiveTerra, &archiveTerraLibraryFolders,
  //      &this->dataPtr->sphericalClipMinDistance);
  //    Ogre::Root::getSingleton().getHlmsManager()->registerHlms(hlmsTerra);

  //    // disable writting debug output to disk
  //    hlmsTerra->setDebugOutputPath(false, false);
  //    hlmsTerra->setListener(hlmsTerra);

  //    this->dataPtr->terraWorkspaceListener.reset(
  //      new Ogre::TerraWorkspaceListener(hlmsTerra));

  //    this->dataPtr->gzHlmsTerra = hlmsTerra;
  //  }
}

//****************************************************************************/
void OgreManager::registerHlmsOriginal(void)
{
  Ogre::ConfigFile cf;
  cf.load(mResourcesCfg);

  Ogre::String dataFolder = cf.getSetting("DoNotUseAsResource", "Hlms", "");

  if (dataFolder.empty())
    dataFolder = "./";
  else if (*(dataFolder.end() - 1) != '/')
    dataFolder += "/";

  Ogre::RenderSystem* renderSystem = mRoot->getRenderSystem();
  Ogre::String shaderSyntax = "GLSL";
  if (renderSystem->getName() == OGRE_RENDERSYSTEM_DIRECTX11)
    shaderSyntax = "HLSL";
  else if (renderSystem->getName() == OGRE_RENDERSYSTEM_METAL)
    shaderSyntax = "Metal";

  Ogre::Archive* archiveLibrary =
      Ogre::ArchiveManager::getSingletonPtr()->load(dataFolder + "Hlms/Common/" + shaderSyntax, "FileSystem", true);
  Ogre::Archive* archiveLibraryAny =
      Ogre::ArchiveManager::getSingletonPtr()->load(dataFolder + "Hlms/Common/Any", "FileSystem", true);
  Ogre::Archive* archivePbsLibraryAny =
      Ogre::ArchiveManager::getSingletonPtr()->load(dataFolder + "Hlms/Pbs/Any", "FileSystem", true);
  Ogre::Archive* archiveUnlitLibraryAny =
      Ogre::ArchiveManager::getSingletonPtr()->load(dataFolder + "Hlms/Unlit/Any", "FileSystem", true);

  Ogre::ArchiveVec library;
  library.push_back(archiveLibrary);
  library.push_back(archiveLibraryAny);

  Ogre::Archive* archiveUnlit =
      Ogre::ArchiveManager::getSingletonPtr()->load(dataFolder + "Hlms/Unlit/" + shaderSyntax, "FileSystem", true);

  library.push_back(archiveUnlitLibraryAny);
  Ogre::HlmsUnlit* hlmsUnlit = OGRE_NEW Ogre::HlmsUnlit(archiveUnlit, &library);
  mRoot->getHlmsManager()->registerHlms(hlmsUnlit);
  library.pop_back();

  Ogre::Archive* archivePbs =
      Ogre::ArchiveManager::getSingletonPtr()->load(dataFolder + "Hlms/Pbs/" + shaderSyntax, "FileSystem", true);

  library.push_back(archivePbsLibraryAny);
  Ogre::HlmsPbs* hlmsPbs = OGRE_NEW Ogre::HlmsPbs(archivePbs, &library);
  mRoot->getHlmsManager()->registerHlms(hlmsPbs);
  library.pop_back();

  if (renderSystem->getName() == "Direct3D11 Rendering Subsystem")
  {
    // Set lower limits 512kb instead of the default 4MB per Hlms in D3D 11.0
    // and below to avoid saturating AMD's discard limit (8MB) or
    // saturate the PCIE bus in some low end machines.
    bool supportsNoOverwriteOnTextureBuffers;
    renderSystem->getCustomAttribute("MapNoOverwriteOnDynamicBufferSRV", &supportsNoOverwriteOnTextureBuffers);

    if (!supportsNoOverwriteOnTextureBuffers)
    {
      hlmsPbs->setTextureBufferDefaultSize(512 * 1024);
      hlmsUnlit->setTextureBufferDefaultSize(512 * 1024);
    }
  }
}

//****************************************************************************/
void OgreManager::renderOgreWidgetsOneFrame(void)
{
  if (mPause)
    return;

  if (mRoot && !mQOgreWidgetMap.isEmpty())
  {
    // Determine time since last frame
    Ogre::Real timeSinceLastFrame = 0.0f;
    unsigned long startTime = 0;
    startTime = mTimer->getMillisecondsCPU();
    timeSinceLastFrame = (mTimer->getMillisecondsCPU() - startTime) / 1000.0f;

    // Update all QOgreWidgets
    QMap<int, QOgreWidget*>::iterator i;
    QOgreWidget* item = 0;
    for (i = mQOgreWidgetMap.begin(); i != mQOgreWidgetMap.end(); ++i)
    {
      item = i.value();
      item->updateOgre(timeSinceLastFrame);
    }

    try
    {
      // Render an one frame
      // Put in a try-catch, because sometimes the application crashes after loading a big mesh
      mRoot->renderOneFrame();
    }
    catch (Ogre::Exception e)
    {
    }
  }

  // const Ogre::FrameStats* framestats = Ogre::Root::getSingletonPtr()->getFrameStats(); // DEBUG
  // Ogre::LogManager::getSingleton().logMessage("Current FPS = " +
  // Ogre::StringConverter::toString(framestats->getAvgFps())); // DEBUG
}

//****************************************************************************/
void OgreManager::registerOgreWidget(int ogreWidgetId, QOgreWidget* ogreWidget)
{
  mQOgreWidgetMap[ogreWidgetId] = ogreWidget;
}

//****************************************************************************/
void OgreManager::unregisterOgreWidget(int ogreWidgetId) { mQOgreWidgetMap.remove(ogreWidgetId); }

//****************************************************************************/
QOgreWidget* OgreManager::getOgreWidget(int ogreWidgetId) const { return mQOgreWidgetMap.value(ogreWidgetId); }

//****************************************************************************/
Ogre::Root* OgreManager::getOgreRoot(void) { return mRoot; }

//****************************************************************************/
void OgreManager::setPause(bool pause) { mPause = pause; }
}  // namespace tesseract_gui
